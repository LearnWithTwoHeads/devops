## Processes

As you execute a command or start up any program on Linux, it will run that as a process. All processes have a lifetime in Linux and goes through various stages during its lifetime. Some processes are more long lived then others. For instance a `nginx` web server (of which we'll learn in a later module) is an infinite process, and can only be stopped if it is externally killed. A command like `ls` is a short lived process as it only prints out some information back to us as we prompt the command line.

We can view all running processes by running `ps aux`. There is going to be a lot of output that consist of numbers time stamps, etc. The important things to note for content we have already learned is the `USER` column. This indicates the user that owns the process that is running. The other thing to note which is new is the `PID` column.

Linux assigns unique identifiers for every process that runs on the machine, and this is what the `PID` is. Once you know the `PID` of a process, you can start to issue different signals to that process from the command line. You can view the different most of the different signals [here](https://faculty.cs.niu.edu/~hutchins/csci480/signals.htm). Let's look at a couple examples:

- `SIGINT`: terminate a program from the terminal. This is generated by pressing Control-C
- `SIGKILL`: terminate the process forcibly at once. This can be done by the command `kill -9 {PID}`
- `SIGTERM`: terminate process gracefully. This can be done by the command `kill {PID}`

Knowing this, if you spot a process on your machine that you want to terminate, you can do that.

Let us now see some of this in action...

On your Linux machine, we will type in the command:


```bash
$ sleep 30 &
```

What this will do is actually suspend a process for the specified amount of time. The `&` character tells Linux to run this process in the background so we can execute more commands since we only have one terminal prompt.

If you were to run the command without `&`, then your terminal will suspend for 30 seconds and you would not be able to type anything in the terminal until those 30 seconds are up.

Now that we have a process that has been initiated, let us view that process with `ps`.


```bash
$ ps aux | grep sleep
```

There are a few important concepts here, but basically what this command is saying in English is "Give me all the running processes on the machine and filter that output for the process `sleep`".

Technically, what is happening, is `ps aux` by default is outputting to what we call `stdout`. The `|` (pipe) character is saying feed this `stdout` output as `stdin` input to the `grep`, command. The `grep` command is for filtering and displaying text from a source. In this case the source happens to be the output of the `ps aux` command.

You can read more about piping/using the pipe character [here](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), and about `stdin`, `stdout`, etc [here](https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/).

For now, the output of the command above should have printed out something like this:

```bash
$ ps aux | grep sleep
ubuntu    195068  0.0  0.1   6188  1028 pts/0    S    14:35   0:00 sleep 30
ubuntu    195141  0.0  0.2   7004  2268 pts/0    S+   14:35   0:00 grep --color=auto sleep
```

The first line is actually the `sleep` process we've executed in the background the command before. The second line is actually the command we just executed. As you can see, the PID here is `195068`, and the user who owns the process is `ubuntu`, which makes sense. So you can actually kill this process if you want to, or just leave it running, but this is all to show the control you have over the lifetime of processes that are running on your Linux machine.

### Resources
Each process in Linux is subject to consume machine resources as necessary. There are three main resources on the machine: CPU, RAM, and disk space. The OS is in charge of determining how resources will get shared amongst processes.

If we type in `ps aux` there two columns to be of note here: %CPU, and %MEM. The %CPU is the amount of CPU that is allocated to the process at the time you executed the `ps aux` command. The same is true for %MEM, but it is the amount of RAM that the process is using.

The `ps aux` is basically a snapshot in time (when you execute the command) of the state of processes and what they are using. This is not particularly useful as processes are always changing in state, and the OS is constantly determining which resources to allocate to the processes. Therefore, Linux has another command we can use for the constant monitoring of processes on the machine: `top`.

```bash
$ top
```

`top` also shows the same information that `ps aux` shows, but it is a long running process that constantly updates. Right now, there is not much going on since there are not many active processes that are running on the machine, but you should see some amount of activity happening, and things changing a bit.

How can we make this more interesting? Because the point of having a machine is for it to be utilized. The machine can be used as a web server to serve content to clients as they request for it. It can also be used for some process that runs on a schedule, etc.

In future modules, we will learn how to do exactly that.